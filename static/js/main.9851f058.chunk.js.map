{"version":3,"sources":["libs/ethereum.ts","states/expore/reducer.ts","services/index.ts","libs/web3.ts","states/hooks.ts","components/Card.tsx","libs/metamask.ts","routes.ts","pages/expore.tsx","pages/myItem.tsx","components/Appbar.tsx","App.tsx","states/test/reducer.ts","states/index.ts","reportWebVitals.ts","index.tsx","../node_modules/magic-sdk/dist/es sync"],"names":["ChainId","getEtherContract","contractDefinition","a","window","ethereum","provider","ethers","providers","Web3Provider","getNetwork","network","Number","parseInt","dev","chainId","signer","getSigner","contract","Contract","networks","address","initialState","nfts","mynfts","exporeSlice","createSlice","name","reducers","setNFTs","state","action","payload","clearNFTs","setMyNFTs","clearMyNFTs","actions","exporeReducer","reducer","loadNFTs","PotatoMarket","marketContract","NFT","ntfContract","fetchMarketItems","marketItems","Promise","all","map","mark","i","tokenURI","tokenId","tokenUri","query","Moralis","Query","equalTo","itemId","toNumber","find","res","data","JSON","parse","get","item","price","toString","seller","owner","image","description","items","console","log","loadMyNFTs","fetchMyNfts","contractEvent","useAppDispatch","useDispatch","useAppSelector","useSelector","CardItem","isForSale","dispatch","handleClick","utils","formatUnits","createMarketSale","value","gasLimit","gasPrice","wait","then","Card","sx","maxWidth","CardHeader","avatar","Avatar","bgcolor","red","IconButton","title","CardMedia","component","height","CardContent","Box","CardActions","disableSpacing","Stack","direction","spacing","Button","variant","endIcon","ShoppingCart","onClick","getWeb3Provider","Web3","getChainId","eth","net","getId","getMetamask","request","method","accounts","getMetamaskAccount","chainChanged","callback","on","routes","path","element","expore","getNFTsData","useEffect","id","p","flexGrow","Grid","container","e","lg","ac","MyAppBar","useMoralis","authenticate","isAuthenticated","isAuthenticating","user","account","logout","formInput","faker","company","companyName","commerce","productDescription","useState","fileTarget","setFileTarget","saveFile","useMoralisFile","createMarket","type","saveIPFS","onSuccess","result","url","ipfs","createSale","onError","error","mintToken","tx","event","events","args","stringify","obj","Object","set","save","parseUnits","getListingPrice","listingPrice","makeMarketItem","undefined","AppBar","position","Container","Toolbar","disableGutters","Typography","noWrap","mr","display","xs","md","page","to","my","color","onChange","target","files","Tooltip","signingMessage","catch","alt","src","App","serverUrl","appId","testSlice","toogle","updateToggle","testReducer","store","configureStore","test","setupListeners","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","AppWrapper","StrictMode","ReactDOM","createRoot","document","getElementById","render","webpackEmptyContext","req","Error","code","keys","resolve","module","exports"],"mappings":"ipBAEYA,E,mQAAAA,K,YAAAA,M,KAIL,IAAMC,EAAgB,uCAAG,WAAOC,GAAP,2BAAAC,EAAA,yDACC,qBAApBC,OAAOC,SADY,0BAEPD,OAAbC,EAFoB,EAEpBA,SACFC,EAAW,IAAIC,IAAOC,UAAUC,aAAaJ,GAHvB,SAKNC,EAASI,aALH,UAKtBC,EALsB,OAMxBC,OAAOC,SAASb,EAAQc,OAASH,EAAQI,QANjB,wBAOpBC,EAASV,EAASW,YAClBC,EAAW,IAAIX,IAAOY,SAAX,UACfjB,EAAmBkB,SAAST,EAAQI,gBADrB,aACf,EAA8CM,QAC9CnB,EAAkB,IAClBc,GAXwB,kBAanBE,GAbmB,iCAgBvB,MAhBuB,4CAAH,sD,0BCWhBI,EAA4B,CACvCC,KAAM,GACNC,OAAQ,IAGJC,EAAcC,YAAY,CAC9BC,KAAM,OACNL,eACAM,SAAU,CACRC,QADQ,SACAC,EAAOC,GACbD,EAAMP,KAAOQ,EAAOC,SAEtBC,UAJQ,SAIEH,GACRA,EAAMP,KAAOD,EAAaC,MAE5BW,UAPQ,SAOEJ,EAAOC,GACfD,EAAMN,OAASO,EAAOC,SAExBG,YAVQ,SAUIL,GACVA,EAAMP,KAAOD,EAAaE,WAOzB,EAAuDC,EAAYW,QAA3DP,EAAR,EAAQA,QAAoBK,GAA5B,EAAiBD,UAAjB,EAA4BC,WACtBG,GADN,EAAuCF,YACjBV,EAAYa,S,kBCrC5BC,EAAQ,uCAAG,oCAAApC,EAAA,sEACQF,EAAiBuC,GADzB,cAChBC,EADgB,gBAEKxC,EAAiByC,GAFtB,cAEhBC,EAFgB,uBAGKF,QAHL,IAGKA,OAHL,EAGKA,EAAgBG,mBAHrB,sJAG4C,GAH5C,eAGhBC,EAHgB,eAKFC,QAAQC,IAC1BF,EAAYG,IAAZ,iCAAAC,MAAgB,WAAOC,GAAP,uBAAA/C,EAAA,6EACSwC,QADT,IACSA,OADT,EACSA,EAAaQ,SAASD,EAAEE,SADjC,cACRC,EADQ,QAGRC,EAAQ,IAAIC,IAAQC,MAAM,oBAC1BC,QAAQ,SAAUP,EAAEQ,OAAOC,YAJnB,SAKIL,EAAMM,OALV,cAKRC,EALQ,OAMRC,EAAOC,KAAKC,MAAMH,EAAI,GAAGI,IAAI,SAE7BC,EAAiB,CACrBC,MAAOjB,EAAEiB,MAAMC,WACfV,OAAQR,EAAEQ,OAAOC,WACjBU,OAAQnB,EAAEmB,OACVC,MAAOpB,EAAEoB,MACTC,MAAOlB,EACP1B,KAAMmC,EAAI,KACVU,YAAaV,EAAI,aAfL,kBAiBPI,GAjBO,4CAAhB,wDANoB,eAKhBO,EALgB,OA0BtBC,QAAQC,IAAR,qBAA0BF,IA1BJ,kBA2BfA,GA3Be,4CAAH,qDA8Bd,SAAeG,IAAtB,+B,4CAAO,oCAAAzE,EAAA,sEACyBF,EAAiBuC,GAD1C,cACCC,EADD,gBAEsBxC,EAAiByC,GAFvC,cAECC,EAFD,uBAGsBF,QAHtB,IAGsBA,OAHtB,EAGsBA,EAAgBoC,cAHtC,sJAGwD,GAHxD,eAGChC,EAHD,eAKeC,QAAQC,IAC1BF,EAAYG,IAAZ,iCAAAC,MAAgB,WAAOC,GAAP,uBAAA/C,EAAA,6EACSwC,QADT,IACSA,OADT,EACSA,EAAaQ,SAASD,EAAEE,SADjC,cACRC,EADQ,QAGRC,EAAQ,IAAIC,IAAQC,MAAM,oBAC1BC,QAAQ,SAAUP,EAAEQ,OAAOC,YAJnB,SAKIL,EAAMM,OALV,cAKRC,EALQ,OAMRC,EAAOC,KAAKC,MAAMH,EAAI,GAAGI,IAAI,SAE7BC,EAAO,CACXC,MAAOjB,EAAEiB,MAAMC,WACfV,OAAQR,EAAEQ,OAAOC,WACjBU,OAAQnB,EAAEmB,OACVC,MAAOpB,EAAEoB,MACTC,MAAOlB,EACP1B,KAAMmC,EAAI,KACVU,YAAaV,EAAI,aAfL,kBAiBPI,GAjBO,4CAAhB,wDANG,eAKCO,EALD,OA0BLC,QAAQC,IAAR,uBAA4BF,IA1BvB,kBA2BEA,GA3BF,4C,4BClCKK,E,SCCCC,EAAiB,kBAAMC,eACvBC,EAAkDC,I,QCqBlDC,EAAW,SAAC,GAA2C,IAAzCrB,EAAwC,EAAxCA,KAAwC,IAAlCsB,iBAAkC,SAC3DC,EAAWN,IAEXO,EAAW,uCAAG,gCAAAnF,EAAA,sEACYF,EAAiBuC,GAD7B,cACZC,EADY,OAGZ0B,EAAQ5D,IAAOgF,MAAMC,YAAY1B,EAAKK,MAAO,OAHjC,SAKa1B,EAAegD,iBAAiB/C,EAAItB,SAAS,MAAMC,QAASyC,EAAKJ,OAAQ,CACtGgC,MAAOvB,EAAMC,WACbuB,SAAU,UACVC,SAAU,gBARM,cAKZH,EALY,gBAUXA,EAAyBI,OAVd,OAWdT,IACF7C,IAAWuD,MAAK,SAAChC,GACfuB,EAASxD,EAAQiC,OAEnBc,IAAakB,MAAK,SAAChC,GACjBuB,EAASnD,EAAU4B,QAhBL,4CAAH,qDAqBjB,OACE,eAACiC,EAAA,EAAD,CAAMC,GAAI,CAAEC,SAAU,KAAtB,UACE,cAACC,EAAA,EAAD,CACEC,OACE,cAACC,EAAA,EAAD,CAAQJ,GAAI,CAAEK,QAASC,IAAI,MAAQ,aAAW,SAA9C,eAIFvE,OACE,cAACwE,EAAA,EAAD,CAAY,aAAW,WAAvB,SACE,cAAC,IAAD,MAGJC,MAAO1C,EAAKnC,OAEd,cAAC8E,EAAA,EAAD,CAAWC,UAAU,MAAMC,OAAO,MAAMpC,MAAOT,EAAKS,QACpD,cAACqC,EAAA,EAAD,UACGxB,GAAa,cAACyB,EAAA,EAAD,oBAAStG,IAAOgF,MAAMC,YAAY1B,EAAKK,MAAO,SAA9C,YAKhB,cAAC2C,EAAA,EAAD,CAAaC,gBAAc,EAA3B,SACG3B,GACC,cAAC4B,EAAA,EAAD,CAAOC,UAAU,MAAMC,QAAS,EAAhC,SACE,cAACC,EAAA,EAAD,CAAQC,QAAQ,YAAYC,QAAS,cAACC,EAAA,EAAD,IAAkBC,QAASjC,EAAhE,yB,4BFxEAR,K,WAAAA,M,KAIL,IAAM0C,EAAe,uCAAG,8BAAArH,EAAA,yDACE,qBAApBC,OAAOC,SADW,yBAEND,OAAbC,EAFmB,EAEnBA,SAFmB,kBAGpB,IAAIoH,IAAKpH,IAHW,gCAKtB,MALsB,2CAAH,qDAQfqH,GAAU,uCAAG,4BAAAvH,EAAA,sEACDqH,IADC,cAClBlH,EADkB,gCAEjBA,QAFiB,IAEjBA,OAFiB,EAEjBA,EAAUqH,IAAIC,IAAIC,SAFD,2CAAH,qDGejBC,GAAW,uCAAG,gCAAA3H,EAAA,yDACa,qBAApBC,OAAOC,SADA,yBAEKD,OAAbC,EAFQ,EAERA,SAFQ,SAGOA,EAAS0H,QAAQ,CAAEC,OAAQ,wBAHlC,cAGVC,EAHU,yBAITA,GAJS,gCAMX,IANW,2CAAH,qDASJC,GAAkB,uCAAG,4BAAA/H,EAAA,sEACT2H,KADS,cAC1BG,EAD0B,gBAGVP,KAHU,cAKhB,OALgB,QAM9BhD,QAAQC,IAAI,mBANkB,kBASzBsD,GATyB,2CAAH,qDAYlBE,GAAe,SAACC,GACI,qBAApBhI,OAAOC,UACKD,OAAbC,SACCgI,GAAG,gBAAgB,SAACvE,GACvBsE,GAAUA,EAASvH,SAASiD,EAAa,SC7CtCwE,GAAmB,CAC9B,CAAE9B,MAAO,SAAU+B,KAAM,GAAIC,QCHT,WACpB,IAAQjH,EAAS0D,GAAe,SAACnD,GAAD,OAAWA,EAAM2G,UAAzClH,KACF8D,EAAWN,IAEjB,SAAS2D,IACPnG,IAAWuD,MAAK,SAAChC,GACfuB,EAASxD,EAAQiC,OAqBrB,OAjBA6E,qBAAU,WACRT,KAAqBpC,MAAK,SAACmC,GACrBA,GAAYA,EAAS,IACvBS,SAGH,IAEHP,GAAY,uCAAC,WAAOS,GAAP,SAAAzI,EAAA,sDACA,OAAPyI,GACFlE,QAAQC,IAAI,mBACZU,EAASxD,EAAQ,MAEjB6G,IALS,2CAAD,uDAUV,cAAC7B,EAAA,EAAD,CAAKgC,EAAG,EAAG7C,GAAI,CAAE8C,SAAU,GAA3B,SACE,cAACC,EAAA,EAAD,CAAMC,WAAS,EAAC9B,QAAS,EAAzB,SACG3F,EAAKyB,KAAI,SAACiG,EAAG/F,GAAJ,OACR,cAAC6F,EAAA,EAAD,CAAM7E,MAAI,EAACgF,GAAI,EAAf,SACE,cAAC,EAAD,CAAUpF,KAAMmF,KADK/F,YD3B/B,CAAEsD,MAAO,UAAW+B,KAAM,UAAWC,QEJjB,WACpB,IHmD6BJ,EGnDrB5G,EAAWyD,GAAe,SAACnD,GAAD,OAAWA,EAAM2G,UAA3CjH,OACF6D,EAAWN,IAEjB,SAAS2D,IACP9D,IAAakB,MAAK,SAAChC,GACjBuB,EAASnD,EAAU4B,OAyBvB,OArBA6E,qBAAU,WACRT,KAAqBpC,MAAK,SAACmC,GACrBA,GAAYA,EAAS,IACvBS,SAGH,IHoC0BN,EGlCd,SAACe,GACdT,KHkC6B,qBAApBtI,OAAOC,UACKD,OAAbC,SACCgI,GAAG,mBAAmB,SAACJ,GAC1BG,GAAUA,EAASH,MGlC3BE,GAAY,uCAAC,WAAOS,GAAP,SAAAzI,EAAA,sDACA,OAAPyI,GACFlE,QAAQC,IAAI,mBACZU,EAASnD,EAAU,MAEnBwG,IALS,2CAAD,uDAUV,cAAC7B,EAAA,EAAD,CAAKgC,EAAG,EAAG7C,GAAI,CAAE8C,SAAU,GAA3B,SACE,cAACC,EAAA,EAAD,CAAMC,WAAS,EAAC9B,QAAS,EAAzB,SACG1F,EAAOwB,KAAI,SAACiG,EAAG/F,GAAJ,OACV,cAAC6F,EAAA,EAAD,CAAM7E,MAAI,EAACgF,GAAI,EAAf,SACE,cAAC,EAAD,CAAUpF,KAAMmF,EAAG7D,WAAW,KADTlC,a,0ECXpBkG,GAAW,WACtB,MAAmFC,cAA3EC,EAAR,EAAQA,aAAcC,EAAtB,EAAsBA,gBAChBlE,GADN,EAAuCmE,iBAAvC,EAAyDC,KAAzD,EAA+DC,QAA/D,EAAwEC,OACvD5E,KAEX6E,EAAwB,CAC5BjI,KAAMkI,KAAMC,QAAQC,cACpBvF,YAAaqF,KAAMG,SAASC,qBAC5B9F,MAAO,KAET,EAAoC+F,qBAApC,oBAAOC,EAAP,KAAmBC,EAAnB,KACQC,EAAaC,cAAbD,SAEFE,EAAY,uCAAG,sBAAApK,EAAA,sDACfgK,GACFE,EAAUF,EAAmBxI,KAAMwI,EAAY,CAC7CK,KAAM,SACNC,UAAU,EACVC,UAAU,WAAD,4BAAE,WAAOC,GAAP,eAAAxK,EAAA,sDACHyK,EAAOD,EAAeE,OAExBF,GACFG,EAAWF,GAJJ,2CAAF,mDAAC,GAOVG,QAAS,SAACC,GAAD,OAAWtG,QAAQC,IAAIqG,MAZjB,2CAAH,qDAiBZF,EAAU,uCAAG,WAAOF,GAAP,yCAAAzK,EAAA,sEAEPwB,EAAsBiI,EAAtBjI,KAAM6C,EAAgBoF,EAAhBpF,YAFC,SAGevE,EAAiBuC,GAHhC,cAGTC,EAHS,gBAIYxC,EAAiByC,GAJ7B,cAITC,EAJS,iBAMSA,EAAYsI,UAAUL,GAN/B,eAMTK,EANS,iBAQGA,EAAkBpF,OARrB,eAQTqF,EARS,OAUTC,EAAQD,EAAGE,OAAO,GAClB1F,EAAQyF,EAAME,KAAK,GACnB3H,EAASgC,EAAM/B,WAEfG,EAAOC,KAAKuH,UAAU,CAC1BV,IAAKA,EACLjJ,OACA6C,iBAGI+G,EAAM,IAAIhI,IAAQiI,OAAO,oBAC3BC,IAAI,SAAU/H,GAClB6H,EAAIE,IAAI,OAAQ3H,GAtBD,UAuBTyH,EAAIG,OAvBK,eAyBTvH,EAAQ5D,IAAOgF,MAAMoG,WAAW/B,EAAUzF,MAAO,SAzBxC,iBA6BY1B,QA7BZ,IA6BYA,OA7BZ,EA6BYA,EAAgBmJ,kBA7B5B,eA6BTC,EA7BS,wBA+BcpJ,QA/Bd,IA+BcA,OA/Bd,EA+BcA,EAAgBqJ,eAC3CpJ,EAAItB,SAAS,MAAMC,QACnBqC,EACAS,EAAMC,WACN,CACEsB,MAAOmG,EAAazH,aApCT,eA+BT0H,EA/BS,iBAwCRA,EAAuBjG,OAxCf,QA0CftD,IAAWuD,MAAK,SAAChC,GACfuB,EAASxD,EAAQiC,OAGnBsG,OAAc2B,GA9CC,kDAgDfrH,QAAQC,IAAI,UAAZ,MAhDe,0DAAH,sDAwDhB,OACE,cAACqH,GAAA,EAAD,CAAQC,SAAS,SAAjB,SACE,cAACC,GAAA,EAAD,CAAWjG,SAAS,KAApB,SACE,eAACkG,GAAA,EAAD,CAASC,gBAAc,EAAvB,UACE,cAACC,GAAA,EAAD,CAAYjF,QAAQ,KAAKkF,QAAM,EAAC5F,UAAU,MAAMV,GAAI,CAAEuG,GAAI,EAAGC,QAAS,CAAEC,GAAI,OAAQC,GAAI,SAAxF,+BAIA,cAAC7F,EAAA,EAAD,CAAKb,GAAI,CAAE8C,SAAU,EAAG0D,QAAS,CAAEC,GAAI,OAAQC,GAAI,SAAnD,SACGpE,GAAOtF,KAAI,SAAC2J,GAAD,OACV,cAAC,IAAD,CAAMC,GAAE,WAAMD,EAAKpE,MAAnB,SACE,cAACpB,EAAA,EAAD,CAAQnB,GAAI,CAAE6G,GAAI,EAAGC,MAAO,QAASN,QAAS,SAA9C,SAA0DG,EAAKnG,SADjCmG,EAAKnG,YAKzC,uBAAOgE,KAAK,OAAOuC,SAnBT,SAAC9D,GACjBmB,EAAcnB,EAAE+D,OAAOC,MAAM,OAmBvB,cAACpG,EAAA,EAAD,CAAKb,GAAI,CAAE8C,SAAU,EAAG0D,QAAS,CAAEC,GAAI,OAAQC,GAAI,SAAnD,SACE,cAACvF,EAAA,EAAD,CACEC,QAAQ,WACR0F,MAAM,YACN9G,GAAI,CAAE6G,GAAI,EAAGC,MAAO,QAASN,QAAS,SACtCjF,QAASgD,EAJX,uBAUF,cAAC1D,EAAA,EAAD,CAAKb,GAAI,CAAE8C,SAAU,GAArB,SACE,cAACoE,GAAA,EAAD,CAAS1G,MAAM,gBAAf,SACE,cAACD,EAAA,EAAD,CACEP,GAAI,CAAE6C,EAAG,GACTtB,QAAS,WACFgC,GACHD,EAAa,CAAE6D,eAAgB,yBAC5BrH,MAAK,SAAU2D,GACd/E,QAAQC,IAAI,kBAAmB8E,GAC/B/E,QAAQC,IAAR,OAAY8E,QAAZ,IAAYA,OAAZ,EAAYA,EAAMxF,IAAI,kBAEvBmJ,OAAM,SAAUpC,GACftG,QAAQC,IAAIqG,OAVtB,SAeE,cAAC5E,EAAA,EAAD,CAAQiH,IAAI,aAAaC,IAAI,8CCxI9BC,OAlBf,WACE,OACE,cAAC,IAAD,CACEC,UAAU,kDACVC,MAAM,2CAFR,SAIE,eAAC,IAAD,WACE,cAAC,GAAD,IACA,cAAC,IAAD,UACGnF,GAAOtF,KAAI,SAACiG,EAAG/F,GAAJ,OACV,cAAC,IAAD,CAAeqF,KAAMU,EAAEV,KAAMC,QAASS,EAAET,WAA5BtF,cCPlBwK,GAAYhM,YAAY,CAC5BC,KAAM,OACNL,aANqC,CACrCqM,QAAQ,GAMR/L,SAAU,CACRgM,aADQ,SACK9L,EAAOC,GAClBD,EAAM6L,OAAS5L,EAAOC,YAQf6L,IADmBH,GAAUtL,QAA3BwL,aACYF,GAAUpL,S,WClB/BwL,GAAQC,YAAe,CAC3BzL,QAAS,CACP0L,KAAMH,GACNpF,OAAQpG,KAIZ4L,aAAeH,GAAMzI,UAENyI,UCAAI,GAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,gCAAqBtI,MAAK,YAAkD,IAA/CuI,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCFRO,GAAa,WACjB,OACE,cAAC,IAAMC,WAAP,UACE,cAAC,IAAD,CAAUb,MAAOA,GAAjB,SACE,cAAC,GAAD,SAMKc,IAASC,WAAWC,SAASC,eAAe,SACpDC,OAAO,cAAC,GAAD,KAKZd,M,gm5oBCvBA,SAASe,EAAoBC,GAC5B,IAAIjG,EAAI,IAAIkG,MAAM,uBAAyBD,EAAM,KAEjD,MADAjG,EAAEmG,KAAO,mBACHnG,EAEPgG,EAAoBI,KAAO,WAAa,MAAO,IAC/CJ,EAAoBK,QAAUL,EAC9BM,EAAOC,QAAUP,EACjBA,EAAoBrG,GAAK,K","file":"static/js/main.9851f058.chunk.js","sourcesContent":["import { ethers } from 'ethers'\r\n\r\nexport enum ChainId {\r\n  dev = '1337'\r\n}\r\n\r\nexport const getEtherContract = async (contractDefinition: Record<string, any>): Promise<ethers.Contract | null> => {\r\n  if (typeof window.ethereum !== 'undefined') {\r\n    const { ethereum } = window\r\n    const provider = new ethers.providers.Web3Provider(ethereum as any)\r\n\r\n    const network = await provider.getNetwork()\r\n    if (Number.parseInt(ChainId.dev) === network.chainId) {\r\n      const signer = provider.getSigner()\r\n      const contract = new ethers.Contract(\r\n        contractDefinition.networks[network.chainId]?.address,\r\n        contractDefinition['abi'],\r\n        signer\r\n      )\r\n      return contract\r\n    }\r\n  }\r\n  return null\r\n}\r\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\r\n// import { RootState } from '..'\r\n\r\nexport interface INFTItem {\r\n  price: string\r\n  itemId: number\r\n  seller: string\r\n  owner: string\r\n  image: any\r\n  name: any\r\n  description: any\r\n}\r\n\r\nexport interface ExporeState {\r\n  nfts: INFTItem[]\r\n  mynfts: INFTItem[]\r\n}\r\nexport const initialState: ExporeState = {\r\n  nfts: [],\r\n  mynfts: []\r\n}\r\n\r\nconst exporeSlice = createSlice({\r\n  name: 'test',\r\n  initialState,\r\n  reducers: {\r\n    setNFTs(state, action: PayloadAction<INFTItem[]>) {\r\n      state.nfts = action.payload\r\n    },\r\n    clearNFTs(state) {\r\n      state.nfts = initialState.nfts\r\n    },\r\n    setMyNFTs(state, action: PayloadAction<INFTItem[]>) {\r\n      state.mynfts = action.payload\r\n    },\r\n    clearMyNFTs(state) {\r\n      state.nfts = initialState.mynfts\r\n    }\r\n  }\r\n})\r\n\r\n// export const getToggleStatus = (state: RootState) => state.test\r\n\r\nexport const { setNFTs, clearNFTs, setMyNFTs, clearMyNFTs } = exporeSlice.actions\r\nexport const exporeReducer = exporeSlice.reducer\r\n","import Moralis from 'moralis'\r\nimport { getEtherContract } from '../libs/ethereum'\r\nimport { INFTItem } from '../states/expore/reducer'\r\nimport PotatoMarket from '../definition/PotatoMarket.json'\r\nimport NFT from '../definition/NFT.json'\r\nimport { NFTInstance, PotatoMarketInstance } from '../../types/truffle-contracts'\r\n\r\nexport const loadNFTs = async () => {\r\n  const marketContract = (await getEtherContract(PotatoMarket)) as unknown as PotatoMarketInstance\r\n  const ntfContract = (await getEtherContract(NFT)) as unknown as NFTInstance\r\n  const marketItems = (await marketContract?.fetchMarketItems()) ?? []\r\n\r\n  const items = await Promise.all(\r\n    marketItems.map(async (i) => {\r\n      const tokenUri = await ntfContract?.tokenURI(i.tokenId)\r\n\r\n      const query = new Moralis.Query('potatoNFTMarket')\r\n      query.equalTo('itemId', i.itemId.toNumber())\r\n      const res = await query.find()\r\n      const data = JSON.parse(res[0].get('data'))\r\n\r\n      const item: INFTItem = {\r\n        price: i.price.toString(),\r\n        itemId: i.itemId.toNumber(),\r\n        seller: i.seller,\r\n        owner: i.owner,\r\n        image: tokenUri,\r\n        name: data['name'],\r\n        description: data['description']\r\n      }\r\n      return item\r\n    })\r\n  )\r\n  console.log(`loadNFTs==>${items}`)\r\n  return items\r\n}\r\n\r\nexport async function loadMyNFTs() {\r\n  const marketContract = (await getEtherContract(PotatoMarket)) as unknown as PotatoMarketInstance\r\n  const ntfContract = (await getEtherContract(NFT)) as unknown as NFTInstance\r\n  const marketItems = (await marketContract?.fetchMyNfts()) ?? []\r\n\r\n  const items = await Promise.all(\r\n    marketItems.map(async (i) => {\r\n      const tokenUri = await ntfContract?.tokenURI(i.tokenId)\r\n\r\n      const query = new Moralis.Query('potatoNFTMarket')\r\n      query.equalTo('itemId', i.itemId.toNumber())\r\n      const res = await query.find()\r\n      const data = JSON.parse(res[0].get('data'))\r\n\r\n      const item = {\r\n        price: i.price.toString(),\r\n        itemId: i.itemId.toNumber(),\r\n        seller: i.seller,\r\n        owner: i.owner,\r\n        image: tokenUri,\r\n        name: data['name'],\r\n        description: data['description']\r\n      }\r\n      return item\r\n    })\r\n  )\r\n  console.log(`loadMyNFTs==>${items}`)\r\n  return items\r\n}\r\n","import { Contract, ContractSendMethod, DeployOptions, EventData } from 'web3-eth-contract'\r\nimport Web3 from 'web3'\r\n\r\nexport enum contractEvent {\r\n  Log = 'Log'\r\n}\r\n\r\nexport const getWeb3Provider = async (): Promise<Web3 | null> => {\r\n  if (typeof window.ethereum !== 'undefined') {\r\n    const { ethereum } = window\r\n    return new Web3(ethereum as any)\r\n  }\r\n  return null\r\n}\r\n\r\nexport const getChainId = async (): Promise<number | undefined> => {\r\n  const provider = await getWeb3Provider()\r\n  return provider?.eth.net.getId()\r\n}\r\n\r\nexport const getWeb3Contract = async (contractDefinition: Record<string, any>): Promise<Contract | null> => {\r\n  const provider = await getWeb3Provider()\r\n  const networkId = await getChainId()\r\n  console.log({ networkId })\r\n\r\n  if (provider && networkId) {\r\n    const contract = new provider.eth.Contract(\r\n      contractDefinition['abi'],\r\n      contractDefinition.networks[networkId]?.address\r\n    )\r\n    return contract\r\n  }\r\n  return null\r\n}\r\n\r\nexport const getContractEvent = (contract: Contract, event: contractEvent): Promise<EventData[]> => {\r\n  const options = {\r\n    filter: {\r\n      value: []\r\n    },\r\n    fromBlock: 0, //Number || \"earliest\" || \"pending\" || \"latest\"\r\n    toBlock: 'latest'\r\n  }\r\n  return contract.getPastEvents(event, options)\r\n}\r\n\r\nexport const deployContract = (contract: Contract): ContractSendMethod => {\r\n  const options: DeployOptions = {\r\n    data: '',\r\n    arguments: []\r\n  }\r\n  return contract.deploy(options)\r\n}\r\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'\r\nimport { AppDispatch, RootState } from '.'\r\n\r\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\r\nexport const useAppDispatch = () => useDispatch<AppDispatch>()\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\r\n","import Card from '@mui/material/Card'\r\nimport CardHeader from '@mui/material/CardHeader'\r\nimport CardMedia from '@mui/material/CardMedia'\r\nimport CardContent from '@mui/material/CardContent'\r\nimport CardActions from '@mui/material/CardActions'\r\nimport Avatar from '@mui/material/Avatar'\r\nimport IconButton from '@mui/material/IconButton'\r\nimport Typography from '@mui/material/Typography'\r\nimport { red } from '@mui/material/colors'\r\nimport MoreVertIcon from '@mui/icons-material/MoreVert'\r\nimport { Box, Button, Stack } from '@mui/material'\r\nimport { ShoppingCart } from '@mui/icons-material'\r\nimport { getEtherContract } from '../libs/ethereum'\r\nimport NFT from '../definition/NFT.json'\r\nimport PotatoMarket from '../definition/PotatoMarket.json'\r\nimport { PotatoMarketInstance } from '../../types/truffle-contracts'\r\nimport { ethers } from 'ethers'\r\nimport { INFTItem, setMyNFTs, setNFTs } from '../states/expore/reducer'\r\nimport { loadMyNFTs, loadNFTs } from '../services'\r\nimport { useAppDispatch } from '../states/hooks'\r\n\r\ninterface ICardItem {\r\n  data: INFTItem\r\n  isForSale?: boolean\r\n}\r\n\r\nexport const CardItem = ({ data, isForSale = true }: ICardItem) => {\r\n  const dispatch = useAppDispatch()\r\n\r\n  const handleClick = async () => {\r\n    const marketContract = (await getEtherContract(PotatoMarket)) as unknown as PotatoMarketInstance\r\n    // const ntfContract = (await getEtherContract(NFT)) as unknown as NFTInstance\r\n    const price = ethers.utils.formatUnits(data.price, 'wei')\r\n\r\n    const createMarketSale = await marketContract.createMarketSale(NFT.networks[1337].address, data.itemId, {\r\n      value: price.toString(),\r\n      gasLimit: '6721975',\r\n      gasPrice: '20000000000'\r\n    })\r\n    await (createMarketSale as any).wait()\r\n    if (isForSale) {\r\n      loadNFTs().then((data) => {\r\n        dispatch(setNFTs(data))\r\n      })\r\n      loadMyNFTs().then((data) => {\r\n        dispatch(setMyNFTs(data))\r\n      })\r\n    }\r\n  }\r\n\r\n  return (\r\n    <Card sx={{ maxWidth: 250 }}>\r\n      <CardHeader\r\n        avatar={\r\n          <Avatar sx={{ bgcolor: red[500] }} aria-label=\"recipe\">\r\n            K\r\n          </Avatar>\r\n        }\r\n        action={\r\n          <IconButton aria-label=\"settings\">\r\n            <MoreVertIcon />\r\n          </IconButton>\r\n        }\r\n        title={data.name}\r\n      />\r\n      <CardMedia component=\"img\" height=\"150\" image={data.image} />\r\n      <CardContent>\r\n        {isForSale && <Box>{`${ethers.utils.formatUnits(data.price, 'ether')} PTT`}</Box>}\r\n        {/* <Typography variant=\"body2\" color=\"text.secondary\">\r\n          {data.description}\r\n        </Typography> */}\r\n      </CardContent>\r\n      <CardActions disableSpacing>\r\n        {isForSale && (\r\n          <Stack direction=\"row\" spacing={2}>\r\n            <Button variant=\"contained\" endIcon={<ShoppingCart />} onClick={handleClick}>\r\n              Buy\r\n            </Button>\r\n          </Stack>\r\n        )}\r\n      </CardActions>\r\n    </Card>\r\n  )\r\n}\r\n","import { getChainId } from './web3'\r\n\r\ndeclare global {\r\n  interface Window {\r\n    ethereum?: EthereumProvider\r\n  }\r\n}\r\n\r\ninterface RequestArguments {\r\n  method: 'eth_requestAccounts' | 'chainChanged' | 'accountsChanged'\r\n  params?: unknown[] | Record<string, unknown>\r\n}\r\n\r\ninterface ConnectInfo {\r\n  chainId: string\r\n}\r\n\r\ntype eventMap = {\r\n  chainChanged: string\r\n  connect: ConnectInfo\r\n  accountsChanged: string[]\r\n}\r\n\r\ntype eventResult<T extends keyof eventMap> = T extends string ? string | string[] : ConnectInfo\r\n\r\nexport interface EthereumProvider {\r\n  request(args: RequestArguments): Promise<string[]>\r\n  on: <T extends keyof eventMap>(event: keyof eventMap, handler: (data: eventResult<T>) => void) => void\r\n}\r\n\r\nconst getMetamask = async (): Promise<string[]> => {\r\n  if (typeof window.ethereum !== 'undefined') {\r\n    const { ethereum } = window\r\n    const accounts = await ethereum.request({ method: 'eth_requestAccounts' })\r\n    return accounts\r\n  }\r\n  return []\r\n}\r\n\r\nexport const getMetamaskAccount = async () => {\r\n  const accounts = await getMetamask()\r\n\r\n  const chainId = await getChainId()\r\n\r\n  if (chainId !== 1337) {\r\n    console.log('incurrect chain')\r\n  }\r\n\r\n  return accounts\r\n}\r\n\r\nexport const chainChanged = (callback?: (chainId: number) => void): void => {\r\n  if (typeof window.ethereum !== 'undefined') {\r\n    const { ethereum } = window\r\n    ethereum.on('chainChanged', (data) => {\r\n      if (callback) callback(parseInt(data as any, 16))\r\n    })\r\n  }\r\n}\r\n\r\nexport const accountChanged = (callback?: (ac: string[]) => void): void => {\r\n  if (typeof window.ethereum !== 'undefined') {\r\n    const { ethereum } = window\r\n    ethereum.on('accountsChanged', (accounts) => {\r\n      if (callback) callback(accounts as any)\r\n    })\r\n  }\r\n}\r\n","import React from 'react'\r\nimport { Expore } from './pages/expore'\r\nimport { MyItem } from './pages/myItem'\r\n\r\ninterface IRoute {\r\n  title: string\r\n  path: string\r\n  element: any\r\n}\r\n\r\nexport const routes: IRoute[] = [\r\n  { title: 'Expore', path: '', element: Expore },\r\n  { title: 'My item', path: 'my-item', element: MyItem }\r\n]\r\n","import { Box, Grid } from '@mui/material'\r\nimport { useEffect } from 'react'\r\nimport { CardItem } from '../components/Card'\r\nimport { chainChanged, getMetamaskAccount } from '../libs/metamask'\r\nimport { loadNFTs } from '../services'\r\nimport { setNFTs } from '../states/expore/reducer'\r\nimport { useAppDispatch, useAppSelector } from '../states/hooks'\r\n\r\nexport const Expore = (): JSX.Element => {\r\n  const { nfts } = useAppSelector((state) => state.expore)\r\n  const dispatch = useAppDispatch()\r\n\r\n  function getNFTsData() {\r\n    loadNFTs().then((data) => {\r\n      dispatch(setNFTs(data))\r\n    })\r\n  }\r\n\r\n  useEffect(() => {\r\n    getMetamaskAccount().then((accounts) => {\r\n      if (accounts && accounts[0]) {\r\n        getNFTsData()\r\n      }\r\n    })\r\n  }, [])\r\n\r\n  chainChanged(async (id) => {\r\n    if (id !== 1337) {\r\n      console.log('incurrect chain')\r\n      dispatch(setNFTs([]))\r\n    } else {\r\n      getNFTsData()\r\n    }\r\n  })\r\n\r\n  return (\r\n    <Box p={4} sx={{ flexGrow: 1 }}>\r\n      <Grid container spacing={1}>\r\n        {nfts.map((e, i) => (\r\n          <Grid item lg={2} key={i}>\r\n            <CardItem data={e} />\r\n          </Grid>\r\n        ))}\r\n      </Grid>\r\n    </Box>\r\n  )\r\n}\r\n","import { useEffect } from 'react'\r\nimport { Box, Grid } from '@mui/material'\r\nimport { CardItem } from '../components/Card'\r\nimport { accountChanged, chainChanged, getMetamaskAccount } from '../libs/metamask'\r\nimport { useAppDispatch, useAppSelector } from '../states/hooks'\r\nimport { loadMyNFTs } from '../services'\r\nimport { setMyNFTs } from '../states/expore/reducer'\r\n\r\nexport const MyItem = (): JSX.Element => {\r\n  const { mynfts } = useAppSelector((state) => state.expore)\r\n  const dispatch = useAppDispatch()\r\n\r\n  function getNFTsData() {\r\n    loadMyNFTs().then((data) => {\r\n      dispatch(setMyNFTs(data))\r\n    })\r\n  }\r\n\r\n  useEffect(() => {\r\n    getMetamaskAccount().then((accounts) => {\r\n      if (accounts && accounts[0]) {\r\n        getNFTsData()\r\n      }\r\n    })\r\n  }, [])\r\n\r\n  accountChanged((ac) => {\r\n    getNFTsData()\r\n  })\r\n\r\n  chainChanged(async (id) => {\r\n    if (id !== 1337) {\r\n      console.log('incurrect chain')\r\n      dispatch(setMyNFTs([]))\r\n    } else {\r\n      getNFTsData()\r\n    }\r\n  })\r\n\r\n  return (\r\n    <Box p={4} sx={{ flexGrow: 1 }}>\r\n      <Grid container spacing={1}>\r\n        {mynfts.map((e, i) => (\r\n          <Grid item lg={2} key={i}>\r\n            <CardItem data={e} isForSale={false} />\r\n          </Grid>\r\n        ))}\r\n      </Grid>\r\n    </Box>\r\n  )\r\n}\r\n","import { useState } from 'react'\r\nimport AppBar from '@mui/material/AppBar'\r\nimport Box from '@mui/material/Box'\r\nimport Toolbar from '@mui/material/Toolbar'\r\nimport IconButton from '@mui/material/IconButton'\r\nimport Typography from '@mui/material/Typography'\r\nimport Container from '@mui/material/Container'\r\nimport Avatar from '@mui/material/Avatar'\r\nimport Button from '@mui/material/Button'\r\nimport Tooltip from '@mui/material/Tooltip'\r\nimport { ethers } from 'ethers'\r\nimport { faker } from '@faker-js/faker'\r\nimport { useMoralis, useMoralisFile } from 'react-moralis'\r\nimport Moralis from 'moralis'\r\nimport PotatoMarket from '../definition/PotatoMarket.json'\r\nimport NFT from '../definition/NFT.json'\r\nimport { PotatoMarketInstance, NFTInstance } from '../../types/truffle-contracts'\r\nimport { getEtherContract } from '../libs/ethereum'\r\nimport { Link } from 'react-router-dom'\r\nimport { routes } from '../routes'\r\nimport { useAppDispatch } from '../states/hooks'\r\nimport { setNFTs } from '../states/expore/reducer'\r\nimport { loadNFTs } from '../services'\r\n\r\n// const client = create({ host: 'localhost', port: 8080, protocol: 'http' })\r\n\r\ninterface IformInput {\r\n  price: string\r\n  name: string\r\n  description: string\r\n}\r\n\r\nexport const MyAppBar = () => {\r\n  const { authenticate, isAuthenticated, isAuthenticating, user, account, logout } = useMoralis()\r\n  const dispatch = useAppDispatch()\r\n\r\n  const formInput: IformInput = {\r\n    name: faker.company.companyName(),\r\n    description: faker.commerce.productDescription(),\r\n    price: '2'\r\n  }\r\n  const [fileTarget, setFileTarget] = useState()\r\n  const { saveFile } = useMoralisFile()\r\n\r\n  const createMarket = async () => {\r\n    if (fileTarget) {\r\n      saveFile((fileTarget as any).name, fileTarget, {\r\n        type: 'base64',\r\n        saveIPFS: true,\r\n        onSuccess: async (result) => {\r\n          const url = (result as any).ipfs()\r\n\r\n          if (result) {\r\n            createSale(url)\r\n          }\r\n        },\r\n        onError: (error) => console.log(error)\r\n      })\r\n    }\r\n  }\r\n\r\n  const createSale = async (url: string) => {\r\n    try {\r\n      const { name, description } = formInput\r\n      const marketContract = (await getEtherContract(PotatoMarket)) as unknown as PotatoMarketInstance\r\n      const ntfContract = (await getEtherContract(NFT)) as unknown as NFTInstance\r\n\r\n      const mintToken = await ntfContract.mintToken(url)\r\n\r\n      const tx = await (mintToken as any).wait()\r\n\r\n      const event = tx.events[0]\r\n      const value = event.args[2]\r\n      const itemId = value.toNumber()\r\n\r\n      const data = JSON.stringify({\r\n        url: url,\r\n        name,\r\n        description\r\n      })\r\n\r\n      const obj = new Moralis.Object('potatoNFTMarket')\r\n      obj.set('itemId', itemId)\r\n      obj.set('data', data)\r\n      await obj.save()\r\n\r\n      const price = ethers.utils.parseUnits(formInput.price, 'ether')\r\n\r\n      /* then list the item for sale on the marketplace */\r\n\r\n      const listingPrice = await marketContract?.getListingPrice()\r\n\r\n      const makeMarketItem = await marketContract?.makeMarketItem(\r\n        NFT.networks[1337].address,\r\n        itemId,\r\n        price.toString(),\r\n        {\r\n          value: listingPrice.toString()\r\n        }\r\n      )\r\n\r\n      await (makeMarketItem as any).wait()\r\n\r\n      loadNFTs().then((data) => {\r\n        dispatch(setNFTs(data))\r\n      })\r\n\r\n      setFileTarget(undefined)\r\n    } catch (error) {\r\n      console.log('Error: ', error)\r\n    }\r\n  }\r\n\r\n  const fileInput = (e: any) => {\r\n    setFileTarget(e.target.files[0])\r\n  }\r\n\r\n  return (\r\n    <AppBar position=\"static\">\r\n      <Container maxWidth=\"xl\">\r\n        <Toolbar disableGutters>\r\n          <Typography variant=\"h6\" noWrap component=\"div\" sx={{ mr: 2, display: { xs: 'none', md: 'flex' } }}>\r\n            Potato NFT Market\r\n          </Typography>\r\n\r\n          <Box sx={{ flexGrow: 1, display: { xs: 'none', md: 'flex' } }}>\r\n            {routes.map((page) => (\r\n              <Link to={`/${page.path}`} key={page.title}>\r\n                <Button sx={{ my: 2, color: 'white', display: 'block' }}>{page.title}</Button>\r\n              </Link>\r\n            ))}\r\n          </Box>\r\n          <input type=\"file\" onChange={fileInput} />\r\n          <Box sx={{ flexGrow: 1, display: { xs: 'none', md: 'flex' } }}>\r\n            <Button\r\n              variant=\"outlined\"\r\n              color=\"secondary\"\r\n              sx={{ my: 2, color: 'white', display: 'block' }}\r\n              onClick={createMarket}\r\n            >\r\n              listing\r\n            </Button>\r\n          </Box>\r\n\r\n          <Box sx={{ flexGrow: 0 }}>\r\n            <Tooltip title=\"Open settings\">\r\n              <IconButton\r\n                sx={{ p: 0 }}\r\n                onClick={() => {\r\n                  if (!isAuthenticated) {\r\n                    authenticate({ signingMessage: 'Log in using Moralis' })\r\n                      .then(function (user) {\r\n                        console.log('logged in user:', user)\r\n                        console.log(user?.get('ethAddress'))\r\n                      })\r\n                      .catch(function (error) {\r\n                        console.log(error)\r\n                      })\r\n                  }\r\n                }}\r\n              >\r\n                <Avatar alt=\"Remy Sharp\" src=\"/static/images/avatar/2.jpg\" />\r\n              </IconButton>\r\n            </Tooltip>\r\n          </Box>\r\n        </Toolbar>\r\n      </Container>\r\n    </AppBar>\r\n  )\r\n}\r\n","import './style.css'\r\n\r\nimport { MoralisProvider } from 'react-moralis'\r\nimport { BrowserRouter, Route, Routes } from 'react-router-dom'\r\nimport { routes } from './routes'\r\nimport { MyAppBar } from './components/Appbar'\r\n\r\nfunction App(): JSX.Element {\r\n  return (\r\n    <MoralisProvider\r\n      serverUrl=\"https://jqffj1drjnzm.usemoralis.com:2053/server\"\r\n      appId=\"iABVUKAeoEkI52Lnjt1dZrIgHuvo62ZHKk9qNDds\"\r\n    >\r\n      <BrowserRouter>\r\n        <MyAppBar />\r\n        <Routes>\r\n          {routes.map((e, i) => (\r\n            <Route key={i} path={e.path} element={e.element()} />\r\n          ))}\r\n        </Routes>\r\n      </BrowserRouter>\r\n    </MoralisProvider>\r\n  )\r\n}\r\n\r\nexport default App\r\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit'\r\nimport { RootState } from '..'\r\n\r\nexport interface TestState {\r\n  toogle: boolean\r\n}\r\nexport const initialState: TestState = {\r\n  toogle: false\r\n}\r\n\r\nconst testSlice = createSlice({\r\n  name: 'test',\r\n  initialState,\r\n  reducers: {\r\n    updateToggle(state, action: PayloadAction<boolean>) {\r\n      state.toogle = action.payload\r\n    }\r\n  }\r\n})\r\n\r\nexport const getToggleStatus = (state: RootState) => state.test\r\n\r\nexport const { updateToggle } = testSlice.actions\r\nexport const testReducer = testSlice.reducer\r\n","import { configureStore } from '@reduxjs/toolkit'\r\nimport { exporeReducer } from './expore/reducer'\r\nimport { testReducer } from './test/reducer'\r\nimport { setupListeners } from '@reduxjs/toolkit/query/react'\r\n\r\nconst store = configureStore({\r\n  reducer: {\r\n    test: testReducer,\r\n    expore: exporeReducer\r\n  }\r\n})\r\n\r\nsetupListeners(store.dispatch)\r\n\r\nexport default store\r\n// Infer the `RootState` and `AppDispatch` types from the store itself\r\nexport type RootState = ReturnType<typeof store.getState>\r\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\r\nexport type AppDispatch = typeof store.dispatch\r\n","import { ReportHandler } from 'web-vitals'\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler):void => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry)\r\n      getFID(onPerfEntry)\r\n      getFCP(onPerfEntry)\r\n      getLCP(onPerfEntry)\r\n      getTTFB(onPerfEntry)\r\n    })\r\n  }\r\n}\r\n\r\nexport default reportWebVitals\r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom/client'\r\nimport App from './App'\r\nimport store from './states'\r\nimport reportWebVitals from './reportWebVitals'\r\nimport { Provider } from 'react-redux'\r\n\r\nconst AppWrapper = () => {\r\n  return (\r\n    <React.StrictMode>\r\n      <Provider store={store}>\r\n        <App />\r\n      </Provider>\r\n    </React.StrictMode>\r\n  )\r\n}\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById('root') as any)\r\nroot.render(<AppWrapper />)\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals()\r\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 696;"],"sourceRoot":""}