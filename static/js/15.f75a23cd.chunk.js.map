{"version":3,"sources":["components/Card.tsx","libs/web3.ts","libs/metamask.ts","pages/MyItem.tsx"],"names":["Image","styled","img","Header","Card","whiteSpace","overflow","textOverflow","Meta","CardItem","Description","data","image","isForSale","price","name","description","owner","useAppDispatch","useContractJson","potatoMarketContract","NFTContract","style","height","width","src","Content","extra","contractEvent","getWeb3Provider","a","window","ethereum","Web3","getChainId","provider","eth","net","getId","getMetamask","request","method","accounts","getMetamaskAccount","console","log","chainChanged","callback","on","parseInt","accountChanged","MyItem","mynfts","useAppSelector","state","expore","dispatch","getNFTsData","useCallback","loadMyNFTs","then","setMyNFTs","useEffect","ac","id","p","sx","flexGrow","container","spacing","map","e","i","item","lg"],"mappings":"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","file":"static/js/15.f75a23cd.chunk.js","sourcesContent":["import { getEtherContract } from '../libs/ethereum'\r\nimport { PotatoMarketInstance } from '../../types/truffle-contracts'\r\nimport { ethers } from 'ethers'\r\nimport { INFTItem, setMyNFTs, setNFTs } from '../states/expore/reducer'\r\nimport { loadMyNFTs, loadNFTs } from '../services'\r\nimport { useAppDispatch } from '../states/hooks'\r\nimport { config } from '../config'\r\nimport { useContractJson } from '../hooks/contracts'\r\nimport { Card, Icon } from 'semantic-ui-react'\r\nimport styled from '@emotion/styled'\r\n\r\nconst Image = styled.img`\r\ndisplay: block;\r\nwidth: 100%;\r\nheight: 14em;\r\nborder-radius: inherit;\r\nobject-fit: cover;`\r\n\r\nconst Header = styled(Card.Header)({\r\n  whiteSpace: 'nowrap',\r\n  overflow: 'hidden',\r\n  textOverflow: 'ellipsis'\r\n})\r\n\r\nconst Meta = styled(Card.Meta)({\r\n  whiteSpace: 'nowrap',\r\n  overflow: 'hidden',\r\n  textOverflow: 'ellipsis'\r\n})\r\n\r\nconst Description = styled(Card.Description)({\r\n  whiteSpace: 'nowrap',\r\n  overflow: 'hidden',\r\n  textOverflow: 'ellipsis'\r\n})\r\n\r\ninterface ICardItem {\r\n  data: INFTItem\r\n  isForSale?: boolean\r\n}\r\n\r\nexport const CardItem = ({ data, isForSale = true }: ICardItem) => {\r\n  const { image, price, description, name, owner } = data\r\n\r\n  const dispatch = useAppDispatch()\r\n  const { potatoMarketContract, NFTContract } = useContractJson()\r\n\r\n  const handleClick = async () => {\r\n    if (potatoMarketContract && NFTContract) {\r\n      const marketContract = (await getEtherContract(\r\n        potatoMarketContract,\r\n        config.marketContractAddress\r\n      )) as unknown as PotatoMarketInstance\r\n      // const ntfContract = (await getEtherContract(NFT)) as unknown as NFTInstance\r\n      const price = ethers.utils.formatUnits(data.price, 'wei')\r\n\r\n      const createMarketSale = await marketContract.createMarketSale(config.nftContractAddress, data.itemId, {\r\n        value: price.toString(),\r\n        gasLimit: '6721975',\r\n        gasPrice: '20000000000'\r\n      })\r\n      await (createMarketSale as any).wait()\r\n      if (isForSale) {\r\n        loadNFTs(potatoMarketContract, NFTContract).then((data) => {\r\n          dispatch(setNFTs(data))\r\n        })\r\n        loadMyNFTs(potatoMarketContract, NFTContract).then((data) => {\r\n          dispatch(setMyNFTs(data))\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n  return (\r\n    <Card style={{ height: \"23em\", width: '100%' }}>\r\n      <Image src={image} />\r\n      <Card.Content>\r\n        <Header>{name}</Header>\r\n        <Meta >\r\n          {owner}\r\n        </Meta>\r\n        {/* <Description>\r\n          {description}\r\n        </Description> */}\r\n      </Card.Content>\r\n      <Card.Content extra>\r\n        <a>\r\n          <Icon name='ethereum' />\r\n          {price}\r\n        </a>\r\n      </Card.Content>\r\n    </Card >\r\n  )\r\n}\r\n","import { Contract, ContractSendMethod, DeployOptions, EventData } from 'web3-eth-contract'\nimport Web3 from 'web3'\n\nexport enum contractEvent {\n  Log = 'Log'\n}\n\nexport const getWeb3Provider = async (): Promise<Web3 | null> => {\n  if (typeof window.ethereum !== 'undefined') {\n    const { ethereum } = window\n    return new Web3(ethereum as any)\n  }\n  return null\n}\n\nexport const getChainId = async (): Promise<number | undefined> => {\n  const provider = await getWeb3Provider()\n  return provider?.eth.net.getId()\n}\n\nexport const getWeb3Contract = async (\n  contractDefinition: Record<string, any>,\n  address: string\n): Promise<Contract | null> => {\n  const provider = await getWeb3Provider()\n  const networkId = await getChainId()\n  console.log({ networkId })\n\n  if (provider && networkId) {\n    const contract = new provider.eth.Contract(contractDefinition['abi'], address)\n    return contract\n  }\n  return null\n}\n\nexport const getContractEvent = (contract: Contract, event: contractEvent): Promise<EventData[]> => {\n  const options = {\n    filter: {\n      value: []\n    },\n    fromBlock: 0, //Number || \"earliest\" || \"pending\" || \"latest\"\n    toBlock: 'latest'\n  }\n  return contract.getPastEvents(event, options)\n}\n\nexport const deployContract = (contract: Contract): ContractSendMethod => {\n  const options: DeployOptions = {\n    data: '',\n    arguments: []\n  }\n  return contract.deploy(options)\n}\n","import { getChainId } from './web3'\n\ndeclare global {\n  interface Window {\n    ethereum?: EthereumProvider\n  }\n}\n\ninterface RequestArguments {\n  method: 'eth_requestAccounts' | 'chainChanged' | 'accountsChanged'\n  params?: unknown[] | Record<string, unknown>\n}\n\ninterface ConnectInfo {\n  chainId: string\n}\n\ntype eventMap = {\n  chainChanged: string\n  connect: ConnectInfo\n  accountsChanged: string[]\n}\n\ntype eventResult<T extends keyof eventMap> = T extends string ? string | string[] : ConnectInfo\n\nexport interface EthereumProvider {\n  request(args: RequestArguments): Promise<string[]>\n  on: <T extends keyof eventMap>(event: keyof eventMap, handler: (data: eventResult<T>) => void) => void\n}\n\nconst getMetamask = async (): Promise<string[]> => {\n  if (typeof window.ethereum !== 'undefined') {\n    const { ethereum } = window\n    const accounts = await ethereum.request({ method: 'eth_requestAccounts' })\n    return accounts\n  }\n  return []\n}\n\nexport const getMetamaskAccount = async () => {\n  const accounts = await getMetamask()\n\n  const chainId = await getChainId()\n\n  if (chainId !== 1337) {\n    console.log('incurrect chain')\n  }\n\n  return accounts\n}\n\nexport const chainChanged = (callback?: (chainId: number) => void): void => {\n  if (typeof window.ethereum !== 'undefined') {\n    const { ethereum } = window\n    ethereum.on('chainChanged', (data) => {\n      if (callback) callback(parseInt(data as any, 16))\n    })\n  }\n}\n\nexport const accountChanged = (callback?: (ac: string[]) => void): void => {\n  if (typeof window.ethereum !== 'undefined') {\n    const { ethereum } = window\n    ethereum.on('accountsChanged', (accounts) => {\n      if (callback) callback(accounts as any)\n    })\n  }\n}\n","import { useCallback, useEffect } from 'react'\r\nimport { Box, Grid } from '@mui/material'\r\nimport { CardItem } from '../components/Card'\r\nimport { accountChanged, chainChanged, getMetamaskAccount } from '../libs/metamask'\r\nimport { useAppDispatch, useAppSelector } from '../states/hooks'\r\nimport { loadMyNFTs } from '../services'\r\nimport { setMyNFTs } from '../states/expore/reducer'\r\nimport { useContractJson } from '../hooks/contracts'\r\n\r\nconst MyItem: React.FC = () => {\r\n  const { mynfts } = useAppSelector((state) => state.expore)\r\n  const dispatch = useAppDispatch()\r\n  const { potatoMarketContract, NFTContract } = useContractJson()\r\n\r\n  const getNFTsData = useCallback(() => {\r\n    if (potatoMarketContract && NFTContract) {\r\n      loadMyNFTs(potatoMarketContract, NFTContract).then((data) => {\r\n        dispatch(setMyNFTs(data))\r\n      })\r\n    }\r\n  }, [potatoMarketContract, NFTContract])\r\n\r\n  useEffect(() => {\r\n    getMetamaskAccount().then((accounts) => {\r\n      if (accounts && accounts[0]) {\r\n        getNFTsData()\r\n      }\r\n    })\r\n  }, [getNFTsData])\r\n\r\n  accountChanged((ac) => {\r\n    getNFTsData()\r\n  })\r\n\r\n  chainChanged(async (id) => {\r\n    if (id !== 1337) {\r\n      console.log('incurrect chain')\r\n      dispatch(setMyNFTs([]))\r\n    } else {\r\n      getNFTsData()\r\n    }\r\n  })\r\n  return (\r\n    <Box p={4} sx={{ flexGrow: 1 }}>\r\n      <Grid container spacing={1}>\r\n        {mynfts.map((e, i) => (\r\n          <Grid item lg={2} key={i}>\r\n            <CardItem data={e} isForSale={false} />\r\n          </Grid>\r\n        ))}\r\n      </Grid>\r\n    </Box>\r\n  )\r\n}\r\n\r\nexport default MyItem\r\n"],"sourceRoot":""}